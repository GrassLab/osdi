

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-TW" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-TW" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Lab 5 : Virtual memory &mdash; nctuos 0.0 說明文件</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/translations.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜尋" href="../search.html" />
    <link rel="next" title="The Assembly You Need" href="../hardware/asm.html" />
    <link rel="prev" title="Lab 4 : Multitasking" href="lab4.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> nctuos
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Labs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="lab0.html">Lab 0: Environment Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="lab1.html">Lab 1 : Hello World</a></li>
<li class="toctree-l1"><a class="reference internal" href="lab2.html">Lab 2 : Bootloader</a></li>
<li class="toctree-l1"><a class="reference internal" href="lab3.html">Lab 3 : Exception and Interrupt</a></li>
<li class="toctree-l1"><a class="reference internal" href="lab4.html">Lab 4 : Multitasking</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Lab 5 : Virtual memory</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#goals-of-this-lab">Goals of this lab</a></li>
<li class="toctree-l2"><a class="reference internal" href="#background">Background</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#terminology">Terminology</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#translation-levels">Translation levels</a></li>
<li class="toctree-l4"><a class="reference internal" href="#page-vs-page-frame-vs-page-table">Page vs Page frame vs Page table</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#page-s-descriptor">Page’s descriptor</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#descriptor-s-format-simplified">Descriptor’s format(simplified)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#attributes-used-in-the-lab">Attributes used in the lab</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#aarch64-memory-layout">AArch64 memory layout</a></li>
<li class="toctree-l3"><a class="reference internal" href="#configuration">Configuration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#required">Required</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#requirement-1">Requirement 1</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#translation-control-register-tcr">Translation Control Register (TCR)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#memory-attribute-indirection-register-mair">Memory attribute indirection register (MAIR)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#identity-paging">Identity paging</a></li>
<li class="toctree-l4"><a class="reference internal" href="#map-kernel-to-the-upper-address-space">Map kernel to the upper address space</a></li>
<li class="toctree-l4"><a class="reference internal" href="#a-finer-granularity-kernel-mapping">A finer granularity kernel mapping</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#requirement-2">Requirement 2</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#page-bookkeeping">Page Bookkeeping</a></li>
<li class="toctree-l4"><a class="reference internal" href="#page-frame-number">Page frame number</a></li>
<li class="toctree-l4"><a class="reference internal" href="#page-alloc-page-free">page_alloc, page_free</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#requirement-3">Requirement 3</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#multitasking-revisiting">Multitasking revisiting</a></li>
<li class="toctree-l4"><a class="reference internal" href="#user-space-paging">User space paging</a></li>
<li class="toctree-l4"><a class="reference internal" href="#user-program-loader">User program loader</a></li>
<li class="toctree-l4"><a class="reference internal" href="#context-switch">Context Switch</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#requirement-4">Requirement 4</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#page-frame-reclaim">Page frame reclaim</a></li>
<li class="toctree-l4"><a class="reference internal" href="#simple-page-fault-handler">Simple page fault handler</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#test-commands">Test commands</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#elective">Elective</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#mmap">mmap</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#api-specification">API specification</a></li>
<li class="toctree-l4"><a class="reference internal" href="#region-page-mapping">Region page mapping</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#elf-loader">ELF loader</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#elf-parsing">ELF parsing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#elf-mapping">ELF mapping</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#page-fault-handler-demand-paging">Page fault handler &amp; demand paging</a></li>
<li class="toctree-l3"><a class="reference internal" href="#copy-on-write">Copy on write</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#on-fork-a-new-task">On fork a new task</a></li>
<li class="toctree-l4"><a class="reference internal" href="#when-either-childs-or-parent-write-to-that-page">When either childs or parent write to that page</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id1">Test commands</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Hardware</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../hardware/asm.html">The Assembly You Need</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hardware/uart.html">UART</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hardware/mailbox.html">Mailbox</a></li>
</ul>
<p class="caption"><span class="caption-text">Miscs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../external_reference/index.html">Exteral Reference</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">nctuos</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Lab 5 : Virtual memory</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/labs/lab5.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="lab-5-virtual-memory">
<h1>Lab 5 : Virtual memory<a class="headerlink" href="#lab-5-virtual-memory" title="本標題的永久連結">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="本標題的永久連結">¶</a></h2>
<p>In the previous lab, you implemented multitasking without virtual memory.
Such implementation works well if the task code and the kernel code are compiled into one single program and share the same address space.</p>
<p>However, things get tricky after you get multiple user programs for different tasks.
For example, programs may use the same linker script and their .text segments would use the same memory address.</p>
<p>Hence, virtual memory is here to provide an ideal memory layout for user programs.
Each user task can access memory as if it has entire control to the address space.
Under the hood, kernel maps virtual memory to physical memory and prevents invalid memory access.</p>
</div>
<div class="section" id="goals-of-this-lab">
<h2>Goals of this lab<a class="headerlink" href="#goals-of-this-lab" title="本標題的永久連結">¶</a></h2>
<ul class="simple">
<li><p>Understand ARMv8-A virtual memory system architecture.</p></li>
<li><p>Understand how to design paging bookkeeping.</p></li>
<li><p>Understand how to design multitasking with virtual memory.</p></li>
<li><p>Understand how user programs loaded.</p></li>
<li><p>Understand how to prevent invalid memory access.</p></li>
<li><p>Understand how demand paging works.</p></li>
<li><p>Understand how copy-on-write works.</p></li>
</ul>
</div>
<div class="section" id="background">
<h2>Background<a class="headerlink" href="#background" title="本標題的永久連結">¶</a></h2>
<div class="section" id="terminology">
<h3>Terminology<a class="headerlink" href="#terminology" title="本標題的永久連結">¶</a></h3>
<div class="section" id="translation-levels">
<h4>Translation levels<a class="headerlink" href="#translation-levels" title="本標題的永久連結">¶</a></h4>
<p>To translate a virtual address to a physical address, it involves levels of translation.
ARMv8-A has 2 to 4 levels of translation for different configurations and has the second stage translation for hypervisor.(not used in labs)</p>
<p>We name each level as in Linux.
The top level is page global directory (PGD) followed by page upper directory (PUD), page middle directory (PMD), and page table entry(PTE).</p>
<p>The entries of PUD, PMD, and PTE could point to page frames.
Hence, it provides different levels of translation.</p>
</div>
<div class="section" id="page-vs-page-frame-vs-page-table">
<h4>Page vs Page frame vs Page table<a class="headerlink" href="#page-vs-page-frame-vs-page-table" title="本標題的永久連結">¶</a></h4>
<p><strong>Page</strong> : A chunck of virtual memory pointed by one entry of PTE.</p>
<p><strong>Block</strong> : A chunck of virtual memory pointed by one entry of PUD or PMD.</p>
<p><strong>Page frame</strong> : A chunck of physical memory.</p>
<p><strong>Page table</strong> : A page frame whose entries point to the next level page tables, blocks, or pages .
In this documentation, PGD, PUD, PMD and PTE are all called page table.</p>
</div>
</div>
<div class="section" id="page-s-descriptor">
<h3>Page’s descriptor<a class="headerlink" href="#page-s-descriptor" title="本標題的永久連結">¶</a></h3>
<p>As mentioned earlier, each entry of a page table point to the next level page table, a block, or a page.
The entry is combined with the page frame physical address and attributes of the region.</p>
<p>We list the necessary content for you.</p>
<div class="section" id="descriptor-s-format-simplified">
<h4>Descriptor’s format(simplified)<a class="headerlink" href="#descriptor-s-format-simplified" title="本標題的永久連結">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Entry of PGD, PUD, PMD which point to a page table

+-----+------------------------------+---------+--+
|     | next level table&#39;s phys addr | ignored |11|
+-----+------------------------------+---------+--+
     47                             12         2  0

Entry of PUD, PMD which point to a block

+-----+------------------------------+---------+--+
|     |  block&#39;s physical address    |attribute|01|
+-----+------------------------------+---------+--+
     47                              n         2  0

Entry of PTE which point to a page

+-----+------------------------------+---------+--+
|     |  page&#39;s physical address     |attribute|11|
+-----+------------------------------+---------+--+
     47                             12         2  0

Invalid entry

+-----+------------------------------+---------+--+
|     |  page&#39;s physical address     |attribute|*0|
+-----+------------------------------+---------+--+
     47                             12         2  0
</pre></div>
</div>
</div>
<div class="section" id="attributes-used-in-the-lab">
<span id="page-attr"></span><h4>Attributes used in the lab<a class="headerlink" href="#attributes-used-in-the-lab" title="本標題的永久連結">¶</a></h4>
<dl class="simple">
<dt><strong>Bits[54]</strong></dt><dd><p>The Unprivileged execute-never bit, non-executable page frame for EL0 if set.</p>
</dd>
<dt><strong>Bits[53]</strong></dt><dd><p>The Privileged execute-never bit, non-executable page frame for EL1 if set.</p>
</dd>
<dt><strong>Bits[47:n]</strong>:</dt><dd><p>The physical address the entry point to.
Note that the address should be aligned to <span class="math notranslate nohighlight">\(2^n\)</span> Byte.</p>
</dd>
<dt><strong>Bits[10]</strong></dt><dd><p>The access flag, a page fault is generated if not set.</p>
</dd>
<dt><strong>Bits[7]</strong></dt><dd><p>0 for read-write, 1 for read-only.</p>
</dd>
<dt><strong>Bits[6]</strong></dt><dd><p>0 for only kernel access, 1 for user/kernel access.</p>
</dd>
<dt><strong>Bits[4:2]</strong></dt><dd><p>The index to MAIR.</p>
</dd>
<dt><strong>Bits[1:0]</strong></dt><dd><p>Specify the next level is a block/page, page table, or invalid.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>If you set Bits[7:6] to 0b01, which means user can read write the region,
then kernel is automatically not executable in that region no matter what the value of Bits[53] is.</p>
</div>
</div>
</div>
<div class="section" id="aarch64-memory-layout">
<h3>AArch64 memory layout<a class="headerlink" href="#aarch64-memory-layout" title="本標題的永久連結">¶</a></h3>
<p>In 64 bit virtual memory system, the upper address space is for kernel and the lower address space is for user.</p>
<img alt="../_images/lab5_0.png" src="../_images/lab5_0.png" />
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>The entire accessible physical address could be linearly mapped by to offset 0xffff_0000_0000_0000 for kernel access in the labs.
It simplfies the design.</p>
</div>
</div>
<div class="section" id="configuration">
<h3>Configuration<a class="headerlink" href="#configuration" title="本標題的永久連結">¶</a></h3>
<p>ARMv8-A has the elasticity for different configurations.
You can change the granularity of paging, the addresible region, etc.
To keep everything simple, the following configuration is specified for this lab.</p>
<ul class="simple">
<li><p>Disable instruction cache.</p></li>
<li><p>Disable data cache.</p></li>
<li><p>Addresible region is 48 bit.</p></li>
<li><p>Page granule size is 4KB.</p></li>
<li><p>Not use address space ID (ASID).</p></li>
</ul>
</div>
<div class="section" id="reference">
<h3>Reference<a class="headerlink" href="#reference" title="本標題的永久連結">¶</a></h3>
<p>So far, we briefly introduce the concept of virtual memory and ARMv8-A virtual memory system architecture.
For details, you can refer to</p>
<ul class="simple">
<li><p><a class="reference external" href="http://static.docs.arm.com/100940/0100/armv8_a_address%20translation_100940_0100_en.pdf">ARMv8-A Address Translation</a></p></li>
<li><p><strong>The AArch64 Virtual Memory System Architecture</strong> of  <a class="reference external" href="http://developer.arm.com/docs/ddi0487/latest/arm-architecture-reference-manual-armv8-for-armv8-a-architecture-profile">ARMv8-A Architecture Reference</a></p></li>
</ul>
</div>
</div>
<div class="section" id="required">
<h2>Required<a class="headerlink" href="#required" title="本標題的永久連結">¶</a></h2>
<div class="section" id="requirement-1">
<h3>Requirement 1<a class="headerlink" href="#requirement-1" title="本標題的永久連結">¶</a></h3>
<p>We provide a step by step tutorial to guide you how to make your original kernel works with virtual memory.
However, we only give necessary explaination in each step.
For details, please refer to the manual.</p>
<div class="section" id="translation-control-register-tcr">
<h4>Translation Control Register (TCR)<a class="headerlink" href="#translation-control-register-tcr" title="本標題的永久連結">¶</a></h4>
<p>Paging is configured by TCR.
The following basic configuration is used in this lab.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define TCR_CONFIG_REGION_48bit (((64 - 48) &lt;&lt; 0) | ((64 - 48) &lt;&lt; 16))</span>
<span class="cp">#define TCR_CONFIG_4KB ((0b00 &lt;&lt; 14) |  (0b10 &lt;&lt; 30))</span>
<span class="cp">#define TCR_CONFIG_DEFAULT (TCR_CONFIG_REGION_48bit | TCR_CONFIG_4KB)</span>

<span class="n">ldr</span> <span class="n">x0</span><span class="p">,</span> <span class="o">=</span> <span class="n">TCR_CONFIG_DEFAULT</span>
<span class="n">msr</span> <span class="n">tcr_el1</span><span class="p">,</span> <span class="n">x0</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">required</span> <span class="pre">1-1</span></code> Set up TCR_EL1.</p>
</div>
<div class="section" id="memory-attribute-indirection-register-mair">
<h4>Memory attribute indirection register (MAIR)<a class="headerlink" href="#memory-attribute-indirection-register-mair" title="本標題的永久連結">¶</a></h4>
<div class="section" id="brief-introduction">
<h5>Brief introduction<a class="headerlink" href="#brief-introduction" title="本標題的永久連結">¶</a></h5>
<p>MMU has different memory <strong>access policies</strong> for different <strong>memory regions</strong>.</p>
<ul class="simple">
<li><p>Memory <strong>access policies</strong> are encoded as attributes and store in MAIR.</p></li>
<li><p>To select attribute for a certain <strong>memory region</strong>, each page table’s entry contains the index to the attribute. (refer to <a class="reference internal" href="#page-attr"><span class="std std-ref">Attributes used in the lab</span></a>)</p></li>
</ul>
<p>When MMU get a virutal address, it get the index from the page table’s entry and looks up MAIR to get the memory attribute.
Then, it access the memory with different access policies.</p>
</div>
<div class="section" id="lab-implementation">
<h5>Lab implementation<a class="headerlink" href="#lab-implementation" title="本標題的永久連結">¶</a></h5>
<p>The following two attributes are used in the lab.</p>
<ul class="simple">
<li><p>Device memory nGnRnE:</p>
<ul>
<li><p>Peripheral access.</p></li>
<li><p>The most restricted memory access.</p></li>
</ul>
</li>
<li><p>Normal memory without cache:</p>
<ul>
<li><p>Normal RAM access.</p></li>
<li><p>Memory gathering, reordering, and speculative execution are possible but without cache.</p></li>
</ul>
</li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define MAIR_DEVICE_nGnRnE 0b00000000</span>
<span class="cp">#define MAIR_NORMAL_NOCACHE 0b01000100</span>
<span class="cp">#define MAIR_IDX_DEVICE_nGnRnE 0</span>
<span class="cp">#define MAIR_IDX_NORMAL_NOCACHE 1</span>

<span class="n">ldr</span> <span class="n">x0</span><span class="p">,</span> <span class="o">=</span><span class="p">(</span> \
  <span class="p">(</span><span class="n">MAIR_DEVICE_nGnRnE</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">MAIR_IDX_DEVICE_nGnRnE</span> <span class="o">*</span> <span class="mi">8</span><span class="p">))</span> <span class="o">|</span> \
  <span class="p">(</span><span class="n">MAIR_NORMAL_NOCACHE</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">MAIR_IDX_NORMAL_NOCACHE</span> <span class="o">*</span> <span class="mi">8</span><span class="p">))</span> \
<span class="p">)</span>
<span class="n">msr</span> <span class="n">mair_el1</span><span class="p">,</span> <span class="n">x0</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">required</span> <span class="pre">1-2</span></code> Set up MAIR_EL1.</p>
</div>
</div>
<div class="section" id="identity-paging">
<h4>Identity paging<a class="headerlink" href="#identity-paging" title="本標題的永久連結">¶</a></h4>
<p>Enable the MMU is the first step for virtual memory.
You can start from identity paging with two level translation.</p>
<p>In two level translation you only need PGD and PUD.
Each entry of PUD points to an 1GB block.
Hence, you only need</p>
<ul class="simple">
<li><p>The first entry of PGD which points to PUD</p></li>
<li><p>The first two entries of PUD.</p>
<ul>
<li><p>The first one maps 0x00000000 - 0x3fffffff (RAM and GPU peripherals)</p></li>
<li><p>The second one maps 0x40000000 - 0x7fffffff(ARM local peripherals).</p></li>
</ul>
</li>
</ul>
<p><strong>setup</strong></p>
<ul class="simple">
<li><p>2 page frames, PGD and PUD.</p></li>
<li><p>PUD’s entries are blocks.</p></li>
<li><p>Map all memory as Device nGnRnE.</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define PD_TABLE 0b11</span>
<span class="cp">#define PD_BLOCK 0b01</span>
<span class="cp">#define PD_ACCESS (1 &lt;&lt; 10)</span>
<span class="cp">#define BOOT_PGD_ATTR PD_TABLE</span>
<span class="cp">#define BOOT_PUD_ATTR (PD_ACCESS | (MAIR_IDX_DEVICE_nGnRnE &lt;&lt; 2) | PD_BLOCK)</span>

<span class="n">mov</span> <span class="n">x0</span><span class="p">,</span> <span class="mi">0</span> <span class="c1">// PGD&#39;s page frame at 0x0</span>
<span class="n">mov</span> <span class="n">x1</span><span class="p">,</span> <span class="mh">0x1000</span> <span class="c1">// PUD&#39;s page frame at 0x1000</span>

<span class="n">ldr</span> <span class="n">x2</span><span class="p">,</span> <span class="o">=</span> <span class="n">BOOT_PGD_ATTR</span>
<span class="n">orr</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="c1">// combine the physical address of next level page with attribute.</span>
<span class="n">str</span> <span class="n">x2</span><span class="p">,</span> <span class="p">[</span><span class="n">x0</span><span class="p">]</span>

<span class="n">ldr</span> <span class="n">x2</span><span class="p">,</span> <span class="o">=</span> <span class="n">BOOT_PUD_ATTR</span>
<span class="n">mov</span> <span class="n">x3</span><span class="p">,</span> <span class="mh">0x00000000</span>
<span class="n">orr</span> <span class="n">x3</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span>
<span class="n">str</span> <span class="n">x3</span><span class="p">,</span> <span class="p">[</span><span class="n">x1</span><span class="p">]</span> <span class="c1">// 1st 1GB mapped by the 1st entry of PUD</span>
<span class="n">mov</span> <span class="n">x3</span><span class="p">,</span> <span class="mh">0x40000000</span>
<span class="n">orr</span> <span class="n">x3</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span>
<span class="n">str</span> <span class="n">x3</span><span class="p">,</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span> <span class="c1">// 2nd 1GB mapped by the 2nd entry of PUD</span>

<span class="n">msr</span> <span class="n">ttbr0_el1</span><span class="p">,</span> <span class="n">x0</span> <span class="c1">// load PGD to the buttom translation based register.</span>

<span class="n">mrs</span> <span class="n">x2</span><span class="p">,</span> <span class="n">sctlr_el1</span>
<span class="n">orr</span> <span class="n">x2</span> <span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="mi">1</span>
<span class="n">msr</span> <span class="n">sctlr_el1</span><span class="p">,</span> <span class="n">x2</span> <span class="c1">// enable MMU, cache remains disabled</span>
</pre></div>
</div>
<p>If you set up correctly, you can print message by UART.</p>
<p><code class="docutils literal notranslate"><span class="pre">required</span> <span class="pre">1-3</span></code> Set up identity mapping.</p>
</div>
<div class="section" id="map-kernel-to-the-upper-address-space">
<h4>Map kernel to the upper address space<a class="headerlink" href="#map-kernel-to-the-upper-address-space" title="本標題的永久連結">¶</a></h4>
<p>As mentioned above, the kernel space is the upper address space.
Now, you need to modify your linker script to make your kernel image can be mapped to the upper address space.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SECTIONS
{
  . = 0xffff000000000000; // kernel space
  . += 0x80000; // kernel load address
  _kernel_start = . ;
  // ...
}
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// ...</span>

<span class="n">msr</span> <span class="n">ttbr0_el1</span><span class="p">,</span> <span class="n">x0</span>
<span class="n">msr</span> <span class="n">ttbr1_el1</span><span class="p">,</span> <span class="n">x0</span> <span class="c1">// also load PGD to the upper translation based register.</span>
<span class="n">mrs</span> <span class="n">x2</span><span class="p">,</span> <span class="n">sctlr_el1</span>
<span class="n">orr</span> <span class="n">x2</span> <span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="mi">1</span>
<span class="n">msr</span> <span class="n">sctlr_el1</span><span class="p">,</span> <span class="n">x2</span>

<span class="n">ldr</span> <span class="n">x2</span><span class="p">,</span> <span class="n">boot_rest</span> <span class="c1">// indirect branch to the virtual address</span>
<span class="n">br</span> <span class="n">x2</span>

<span class="nl">boot_rest</span><span class="p">:</span>
<span class="c1">// ...</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">required</span> <span class="pre">1-4</span></code> Modify linker script and map the upper address space.</p>
<p><code class="docutils literal notranslate"><span class="pre">question</span> <span class="pre">1</span></code> Without indirect branch, the code might still work fine, why it’s the case and why it’s mandatory to use indirect branch.</p>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>Memory mapped IO address may also need to be modified.</p>
</div>
</div>
<div class="section" id="a-finer-granularity-kernel-mapping">
<h4>A finer granularity kernel mapping<a class="headerlink" href="#a-finer-granularity-kernel-mapping" title="本標題的永久連結">¶</a></h4>
<p>The granularity of two level translation is 1GB.
In the previous setting, all memory regions are mapped as device memory.</p>
<p>However, unaligned access of device memory causes alignment fault and the compiler sometimes generates unaligned access.
Hence, you should map most of the RAM as normal memory and MMIO region as device memory.</p>
<p>Then, you should use three level translation(2MB) or four level translation(4KB) for linear mapping.</p>
<p><code class="docutils literal notranslate"><span class="pre">required</span> <span class="pre">1-5</span></code> Linear map kernel with finer granularity and map RAM as normal memory.</p>
<p><code class="docutils literal notranslate"><span class="pre">question</span> <span class="pre">2</span></code> For mapping 1GB memory region, how many page frames are used by page tables(PGD, PUD, PMD, and PTE) in four level translation?</p>
</div>
</div>
<div class="section" id="requirement-2">
<h3>Requirement 2<a class="headerlink" href="#requirement-2" title="本標題的永久連結">¶</a></h3>
<div class="section" id="page-bookkeeping">
<h4>Page Bookkeeping<a class="headerlink" href="#page-bookkeeping" title="本標題的永久連結">¶</a></h4>
<p>With paging enabled, you can treat physical memory as set of page frames.
Page frames are valuable resource and can be used for different purposes such as</p>
<ul class="simple">
<li><p>memory pool for kernel objects</p></li>
<li><p>file cache</p></li>
<li><p>physical memory for user space.</p></li>
</ul>
<p>Same as <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task</span></code> , you need to design your own <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span></code>.
Each <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span></code> refer to one page frame.
Your kernel bookkeeps the the use of the page frame in <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">required</span> <span class="pre">2-1</span></code> Implement page bookkeeping.</p>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>Some physical memory regions are already in used (e.g. the memory region used by the kernel image).
Hence, you need to mark the corresponding page frames as in used.</p>
</div>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p>Rpi3 has 1GB RAM and the page size is 4KB, so a statically declared array <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page[262144]</span></code> is enough to bookkeep the status of page frames.
You can also declare a smaller array such as <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page[1000]</span></code>, and only use 1000 page frames in this lab.</p>
</div>
</div>
<div class="section" id="page-frame-number">
<h4>Page frame number<a class="headerlink" href="#page-frame-number" title="本標題的永久連結">¶</a></h4>
<p>To keep track of each page frame, you can use page frame number(PFN) to index them.
The PFN of physical address is [47:12] bitfield.
You can also use PFN to index the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span></code> array.</p>
<p>It’s common to translate kernel virtual address, physical address, PFN and the reference to <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span></code>.
You should implement the translation function for future use.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Kernel virtual address : 0xffff000012345678
Physical address       : 0x0000000012345678
                           |___________|
                                PFN
PFN                    : 0x0000000000012345
page descriptor        : struct page[0x12345]
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">required</span> <span class="pre">2-2</span></code> Implement the translation function between kernel virtual address, physical address,  PFN and the reference to <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span></code>.</p>
</div>
<div class="section" id="page-alloc-page-free">
<h4>page_alloc, page_free<a class="headerlink" href="#page-alloc-page-free" title="本標題的永久連結">¶</a></h4>
<p>You need to implement the allocation and free of a page frame.
For each allocated page frame, initialize it to 0.</p>
<p><code class="docutils literal notranslate"><span class="pre">required</span> <span class="pre">2-3</span></code> Implement page_alloc and page_free.</p>
<p><code class="docutils literal notranslate"><span class="pre">question</span> <span class="pre">3</span></code> If a page frame is allocated and to be mapped at user space. Is it necessary to initialize it into 0?</p>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>The next lab’s subject is allocator, you’ll re-write everything for page initialization and allocation.
Hence, keep it simple.</p>
</div>
</div>
</div>
<div class="section" id="requirement-3">
<h3>Requirement 3<a class="headerlink" href="#requirement-3" title="本標題的永久連結">¶</a></h3>
<div class="section" id="multitasking-revisiting">
<h4>Multitasking revisiting<a class="headerlink" href="#multitasking-revisiting" title="本標題的永久連結">¶</a></h4>
<p>In the previous lab, you implemented multitasking without MMU.
Now with MMU enabled, you can create different address space for different user tasks.</p>
</div>
<div class="section" id="user-space-paging">
<h4>User space paging<a class="headerlink" href="#user-space-paging" title="本標題的永久連結">¶</a></h4>
<div class="section" id="pgd-allocation">
<h5>PGD allocation<a class="headerlink" href="#pgd-allocation" title="本標題的永久連結">¶</a></h5>
<p>Different address spaces for user tasks can be achived by setting TTBR0_EL1 to different PGDs.</p>
<p>On user task creation, a page frame is allocated as PGD for task’s address space.</p>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>You should use 4KB page for user task in this lab, so you need PGD, PUD, PMD, and PTE for four layer translation.</p>
</div>
</div>
<div class="section" id="user-space-mapping">
<h5>User space mapping<a class="headerlink" href="#user-space-mapping" title="本標題的永久連結">¶</a></h5>
<p>Same as kernel space mapping, you need to iteratively fill in the entries of page tables from PGD -&gt; PUD -&gt; PMD -&gt; PTE.</p>
<p>During this process, the next level page tables such as PUD, PMD, and PTE may not already present.
You should allocate one page frame as the next level page table then fill in its entry.</p>
<p><code class="docutils literal notranslate"><span class="pre">required</span> <span class="pre">3-1</span></code> Implement user space paging.</p>
</div>
</div>
<div class="section" id="user-program-loader">
<h4>User program loader<a class="headerlink" href="#user-program-loader" title="本標題的永久連結">¶</a></h4>
<p>In general purpose OS, the user code should be compiled to a program and to be loaded by OS.
Now, you need to implement a user programe loader.
Your kernel loads the user program and create a new user virtual address space.</p>
<p>In the required part, you only need to implement the <strong>raw binary loader</strong>.
It’s simpler but with some downsides such as the loader can’t distinguish the segments of the program.</p>
<div class="section" id="user-library">
<h5>User library<a class="headerlink" href="#user-library" title="本標題的永久連結">¶</a></h5>
<p>Remember that your first program in C.
You only write the main function and return 0, and your code magically works.
Actually, your main is called by libc or crt library, and after returning from main, it also calls <code class="docutils literal notranslate"><span class="pre">exit</span></code> for you.</p>
<p>Now, you should implement a minimum user library.
It provides the <strong>entry point</strong>, <strong>call exit</strong> after return from main, and <strong>encapsulate system calls</strong> as APIs.</p>
<p>The user library also need to provide <strong>common functions</strong> such as print, memory copy.
These functions may rely on system calls, user library should wrap it and hide the details for programmers.
Programmers only need to write the main function and link to the library for other utilities.</p>
<p><code class="docutils literal notranslate"><span class="pre">required</span> <span class="pre">3-1</span></code> Implement a minimum user library.</p>
</div>
<div class="section" id="implement-shell-as-an-user-program">
<h5>Implement shell as an user program<a class="headerlink" href="#implement-shell-as-an-user-program" title="本標題的永久連結">¶</a></h5>
<p>You should write your user shell, compile it and link to your minimum user library.
There is one pitfall that the raw binary loader can’t get the information about .bss from raw binary.</p>
<p>Hence, you’d better prevent creating .bss.
When you need 0 initialized global/static variables, you should explicitly 0 initialize it and add -fno-zero-initialized-in-bss compiler flag.
Then, the variables will be put into .data and be preserved after objcopy.</p>
<p>The following picture shows how to create 0 initialized data to .data.</p>
<img alt="../_images/lab5_3.png" src="../_images/lab5_3.png" />
<p><code class="docutils literal notranslate"><span class="pre">required</span> <span class="pre">3-2</span></code> Implement shell as an user program and use <strong>objcopy</strong> to turn the ELF file into a raw binary.</p>
</div>
<div class="section" id="embed-compiled-binary-to-kernel">
<h5>Embed compiled binary to kernel<a class="headerlink" href="#embed-compiled-binary-to-kernel" title="本標題的永久連結">¶</a></h5>
<p>Two approaches are provided for you to embed binaries into your kernel.
Both makes encapsulate the binary as an object file, and you can link it to kernel and get them by symbol’s virtual address.</p>
<p><strong>By ld</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">ld</span> <span class="pre">-r</span> <span class="pre">-b</span> <span class="pre">binary</span> <span class="pre">&lt;input</span> <span class="pre">bin&gt;</span> <span class="pre">-o</span> <span class="pre">&lt;output</span> <span class="pre">name&gt;</span></code></p>
<p>It creates an linkable binary object with 3 symbols,</p>
<ul class="simple">
<li><p>_binary_&lt;input name&gt;_start</p></li>
<li><p>_binary_&lt;input name&gt;_end</p></li>
<li><p>_binary_&lt;input name&gt;_size</p></li>
</ul>
<p><strong>By assembler</strong></p>
<p>.incbin is an assembler directive.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">global</span> <span class="n">bin_start</span>
<span class="nl">bin_start</span><span class="p">:</span>
<span class="p">.</span><span class="n">incbin</span> <span class="s">&quot;&lt;input_file&gt;&quot;</span>
</pre></div>
</div>
<img alt="../_images/lab5_2.png" src="../_images/lab5_2.png" />
<p><code class="docutils literal notranslate"><span class="pre">required</span> <span class="pre">3-3</span></code> Embed your shell binary to kernel image.</p>
</div>
<div class="section" id="raw-binary-loading-and-mapping">
<h5>Raw binary loading and mapping<a class="headerlink" href="#raw-binary-loading-and-mapping" title="本標題的永久連結">¶</a></h5>
<p>Your shell is now embeded into your kernel image and your kernel image can get it by the binary start symbol.
You should replace the function pointer argument in <code class="docutils literal notranslate"><span class="pre">do_exec</span></code> by binary start symbol.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">do_exec</span></code>, it acts as a binary loader and do the following things.</p>
<ol class="arabic simple">
<li><p>Allocate user’s virtual address space(PGD).</p></li>
<li><p>Allocate page frames and maps the memory region for the raw binary.</p></li>
<li><p>Copies the raw binary to the memory region.</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>The loader can’t distinguish segments of raw binary, so you can just map the entire binary as read/write/exectable.</p>
</div>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p>If you are not sure what’s the virtual address to be mapped, you can use <code class="docutils literal notranslate"><span class="pre">readelf</span> <span class="pre">-l</span> <span class="pre">&lt;compiled_ELF&gt;</span></code>.  to get the VirtAddr of the 1st LOAD segment.
Then hard-code it as the virtual address start and map the entire program binary.</p>
</div>
</div>
<div class="section" id="user-stacks-with-the-same-virtual-address">
<h5>User stacks with the same virtual address<a class="headerlink" href="#user-stacks-with-the-same-virtual-address" title="本標題的永久連結">¶</a></h5>
<p>In the previous lab, user stacks are statically declared and each task use different address for its user stack.
With virtual memory, each task has its address space and can refer to different physical address with the same virtual address.
Therefore, each user task can use the same virtual address to their own user stack.</p>
<p>Change your user stack implementation to:</p>
<ul class="simple">
<li><p>Dynamically allocate one page frame for the user stack.</p></li>
<li><p>All user tasks use the same virtual address 0x0000_ffff_ffff_e000 for user stack..</p>
<ul>
<li><p>You should map the address to the allocated page frame.</p></li>
</ul>
</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">required</span> <span class="pre">3-4</span></code> Allocate one page frame for user stack and map user task’s stack to the common address.</p>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>Currently, kernel stacks are still statically declared and allocated.
Kernel stack allocation will also be dynamically allocated in the next lab.</p>
</div>
</div>
</div>
<div class="section" id="context-switch">
<h4>Context Switch<a class="headerlink" href="#context-switch" title="本標題的永久連結">¶</a></h4>
<p>To switch between tasks with different address spaces,
you can load translation based register(TTBR0_EL1) with different PGD.</p>
<p>In addition, you might need memory barriers to guarantee previous instructions are finished.
Also, a TLB invalidation is need because the old values are staled.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ldr</span> <span class="n">x0</span><span class="p">,</span> <span class="o">=</span> <span class="n">next_pgd</span>
<span class="n">dsb</span> <span class="n">ish</span> <span class="c1">// ensure write has completed</span>
<span class="n">msr</span> <span class="n">ttbr0_el1</span><span class="p">,</span> <span class="n">x0</span> <span class="c1">// switch translation based address.</span>
<span class="n">tlbi</span> <span class="n">vmalle1is</span> <span class="c1">// invalidate all TLB entries</span>
<span class="n">dsb</span> <span class="n">ish</span> <span class="c1">// ensure completion of TLB invalidatation</span>
<span class="n">isb</span> <span class="c1">// clear pipeline</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">required</span> <span class="pre">3-4</span></code> Set TTBR0_EL1 to switch between different address space when context switch.</p>
</div>
</div>
<div class="section" id="requirement-4">
<h3>Requirement 4<a class="headerlink" href="#requirement-4" title="本標題的永久連結">¶</a></h3>
<div class="section" id="page-frame-reclaim">
<h4>Page frame reclaim<a class="headerlink" href="#page-frame-reclaim" title="本標題的永久連結">¶</a></h4>
<p>After an user task exits, the <strong>page frames allocated</strong> by the user task <strong>including page tables</strong> should be reclaimed by the <strong>exited user task itself</strong>.
So, the remaining number of page frames should be the same before a user task create and after it exit,</p>
<p><code class="docutils literal notranslate"><span class="pre">required</span> <span class="pre">4-1</span></code> Implement page frame reclaim.</p>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>User task can reclaim the allocated page frames itself because those page frames are only used for user space.
And an exited zombie should never access user space anymore.</p>
<p>However, some memory resource such as kernel stack should not be reclaimed by an exited zombie itself because it’s still using it.
And the task reaper will reclaim it.</p>
</div>
</div>
<div class="section" id="simple-page-fault-handler">
<h4>Simple page fault handler<a class="headerlink" href="#simple-page-fault-handler" title="本標題的永久連結">¶</a></h4>
<p>When CPU access a non-mapped address, a page fault exception is taken.
You should <strong>print the fault address</strong> store in FAR_EL1 in the kernel mode and <strong>kill the user task</strong>.</p>
<p><code class="docutils literal notranslate"><span class="pre">required</span> <span class="pre">4-2</span></code> Implement simple page fault handler.</p>
</div>
</div>
<div class="section" id="test-commands">
<h3>Test commands<a class="headerlink" href="#test-commands" title="本標題的永久連結">¶</a></h3>
<p>The following test commands are recommended to be added to your user shell to test the requirements.
If you don’t follow it, you need to guarantee that your testing code meet our requirements.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">test_command1</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// test fork functionality</span>
  <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="n">fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fork</span><span class="p">();</span>
    <span class="n">fork</span><span class="p">();</span>
    <span class="k">while</span><span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;task id: %d, sp: 0x%llx cnt: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">get_taskid</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">cnt</span><span class="p">,</span> <span class="n">cnt</span><span class="o">++</span><span class="p">);</span> <span class="c1">// address should be the same across tasks, but the cnt should be increased indepndently</span>
      <span class="n">delay</span><span class="p">(</span><span class="mi">1000000</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// all childs exit</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">test_command2</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// test page fault</span>
  <span class="k">if</span><span class="p">(</span><span class="n">fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span> <span class="c1">// a non-mapped address.</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">);</span> <span class="c1">// trigger simple page fault, child will die here.</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">test_command3</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// test page reclaim.</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Remaining page frames : %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">remain_page_num</span><span class="p">());</span> <span class="c1">// get number of remaining page frames from kernel by system call.</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="elective">
<h2>Elective<a class="headerlink" href="#elective" title="本標題的永久連結">¶</a></h2>
<div class="section" id="mmap">
<h3>mmap<a class="headerlink" href="#mmap" title="本標題的永久連結">¶</a></h3>
<p>You use different address space for different tasks, so different tasks are unable to touch others』 memory.
However, It’s common that programmers accidentaly touch a memory region they should not do in its own address space.
Kernel should notice that is an invalid access.</p>
<p>You can divide the user address space into several <strong>regions with different protection</strong> such as
read-executalbe for code, read-write for normal data, and read-only for read only data.</p>
<p><code class="docutils literal notranslate"><span class="pre">mmap</span></code> is the system call to create such regions.
Each region can be mapped to a file or anonymous page(the page frames not related any file).
Then, users can create <strong>heap</strong>, <strong>memory mapped file</strong> by the system call.</p>
<p>Besides, kernel also use it for <strong>program loader</strong> implementation.
The loading of a program can be done by <strong>memory mapped file</strong>.
Memory regions for <strong>.bss</strong> and <strong>user stack</strong> can be done by <strong>anonymous page mapping</strong>.</p>
<div class="section" id="api-specification">
<h4>API specification<a class="headerlink" href="#api-specification" title="本標題的永久連結">¶</a></h4>
<dl>
<dt>(void*) mmap(void* addr, size_t len, int prot, int flags, void* file_start, int file_offset)</dt><dd><p>kernel use <strong>addr</strong> and <strong>len</strong> to create new region.</p>
<blockquote>
<div><ul>
<li><p>If <strong>addr</strong> is NULL, kernel decides the new region’s start address</p></li>
<li><p>If <strong>addr</strong> is not NULL</p>
<blockquote>
<div><ul class="simple">
<li><p>If the new region <strong>overlap</strong> with existing regions, or <strong>addr</strong> is <strong>not page aligned</strong></p>
<ul>
<li><p>If MAP_FIXED is set, <code class="docutils literal notranslate"><span class="pre">mmap</span></code> is failed</p></li>
<li><p>Otherwise, kernel takes <strong>addr</strong> as hint and decides the new region’s start address.</p></li>
</ul>
</li>
<li><p>Otherwise, kernel use <strong>addr</strong> as new region’s start address.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>The memory region created by <code class="docutils literal notranslate"><span class="pre">mmap</span></code> should be page aligned, if the <strong>len</strong> is not multiple of page size, elevate it to be align to page.</p></li>
</ul>
</div></blockquote>
<p><strong>prot</strong> specify the regions access protection</p>
<blockquote>
<div><ul class="simple">
<li><p>PROT_NONE : not accessible</p></li>
<li><p>PROT_READ : readable</p></li>
<li><p>PROT_WRITE : writable</p></li>
<li><p>PROT_EXEC : executable</p></li>
</ul>
</div></blockquote>
<p>The following <strong>flags</strong> should be implemented</p>
<blockquote>
<div><ul class="simple">
<li><p>MAP_FIXED: New region’s start should be <strong>addr</strong>, or the <code class="docutils literal notranslate"><span class="pre">mmap</span></code> is failed</p></li>
<li><p>MAP_ANONYMOUS: New region is mapped to anonymous page. It’s usaully used for stack and heap.</p></li>
<li><p>MAP_POPULATE: After <code class="docutils literal notranslate"><span class="pre">mmap</span></code>, it directly do <a class="reference internal" href="#region-map"><span class="std std-ref">Region page mapping</span></a>.(You don’t have to implement it if you implement demand paging)</p></li>
</ul>
</div></blockquote>
<p><strong>file_start</strong> specify the mapped file.</p>
<blockquote>
<div><ul class="simple">
<li><p>Originally, it should be a file descriptor, but the filesystem is not implemented yet.</p></li>
<li><p>So, <strong>file_start</strong> is set to the <strong>binary’s start symbol</strong> for workaround.</p></li>
</ul>
</div></blockquote>
<p><strong>file_offset</strong> specify the new region’s start from the offset of the mapped file.</p>
<blockquote>
<div><ul class="simple">
<li><p>The file_offset should be page aligned.</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">備註</p>
<ul class="simple">
<li><p>You don’t need to handle the case that the new mmap region overlap existing regions.</p></li>
<li><p>We use memory mapped file for ELF loader, if you don’t implement ELF loader, you don’t need to implement <strong>file_start</strong>, <strong>file_offset</strong>, and <strong>MAP_FIXED</strong>.</p></li>
</ul>
</div>
<p><code class="docutils literal notranslate"><span class="pre">elective</span> <span class="pre">1-1</span></code> Implement <code class="docutils literal notranslate"><span class="pre">mmap</span></code> for creating a new region.</p>
</div>
<div class="section" id="region-page-mapping">
<span id="region-map"></span><h4>Region page mapping<a class="headerlink" href="#region-page-mapping" title="本標題的永久連結">¶</a></h4>
<p>Once a region is created, kernel could create page mapping for the region.</p>
<ul class="simple">
<li><p>If the region is mapped to an anonymous page frames</p>
<ol class="arabic simple">
<li><p>Allocate page frames</p></li>
<li><p>Map memory region to page frames and the page attributes are set according to region’s protection policy.</p></li>
</ol>
</li>
<li><p>If the region is mapped a file</p>
<ol class="arabic simple">
<li><p>Allocate page frames</p></li>
<li><p>Map memory region to page frames and the page attributes are set according to region’s protection policy.</p></li>
<li><p>Copy the file content to the memory region.</p></li>
</ol>
</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">elective</span> <span class="pre">1-2</span></code> Implement Region page mapping.</p>
</div>
</div>
<div class="section" id="elf-loader">
<span id="elf"></span><h3>ELF loader<a class="headerlink" href="#elf-loader" title="本標題的永久連結">¶</a></h3>
<div class="section" id="elf-parsing">
<h4>ELF parsing<a class="headerlink" href="#elf-parsing" title="本標題的永久連結">¶</a></h4>
<p>The difference between raw binary and ELF is the header.
You can get segments information by parsing the ELF file’s header</p>
<p>To implement a ELF loader, you only need to care about ELF header and program headers.
The following are struct member you need to use for loading a statically linking ELF.</p>
<div class="section" id="elf-header">
<h5>ELF header<a class="headerlink" href="#elf-header" title="本標題的永久連結">¶</a></h5>
<ul class="simple">
<li><p><strong>e_entry</strong>: The ELF’s entry point, you need to set user exception return address to it.</p></li>
<li><p><strong>e_phoff</strong>: The offset of program headers from ELF’s file start.</p></li>
<li><p><strong>e_phnum</strong>: The number of program headers</p></li>
</ul>
</div>
<div class="section" id="program-header">
<h5>Program header<a class="headerlink" href="#program-header" title="本標題的永久連結">¶</a></h5>
<ul class="simple">
<li><p><strong>p_type</strong>: The type of program header, you only need to care about PT_LOAD (LOAD segments).</p></li>
<li><p><strong>p_vaddr</strong>: The virtual address should be loaded to.</p></li>
<li><p><strong>p_offset</strong>: The offset to start of ELF.</p></li>
<li><p><strong>p_align</strong>: <strong>p_vaddr</strong> <span class="math notranslate nohighlight">\(\equiv\)</span> <strong>p_offset</strong> (mod <strong>p_align</strong>)</p></li>
<li><p><strong>p_filesz</strong>: The file size, contains .text, .data, etc.</p></li>
<li><p><strong>p_memsz</strong>: The memory size of the segment. It usualy equals to <strong>p_filesz</strong>. If the segment contains .bss, it should be larger than <strong>p_filesz</strong></p></li>
<li><p><strong>p_flags</strong>: The extra flags, you only need to care about rwx.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>Don’t confuse the <strong>p_offset</strong> with <strong>file_offset</strong> in <code class="docutils literal notranslate"><span class="pre">mmap</span></code>. <strong>p_offset</strong> may not be page aligned.</p>
<p>Don’t confuse the <strong>p_vaddr</strong> with <strong>addr</strong> in <code class="docutils literal notranslate"><span class="pre">mmap</span></code>. <strong>p_vaddr</strong> may not be page aligned.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">elective</span> <span class="pre">2-1</span></code> Parse the ELF header.</p>
<div class="admonition hint">
<p class="admonition-title">提示</p>
<p>You can check the correctness by readelf -l &lt;your ELF&gt; on linux</p>
</div>
</div>
<div class="section" id="elf-reference">
<h5>ELF reference<a class="headerlink" href="#elf-reference" title="本標題的永久連結">¶</a></h5>
<ul class="simple">
<li><p><a class="reference external" href="https://www.sco.com/developers/gabi/latest/ch4.eheader.html">https://www.sco.com/developers/gabi/latest/ch4.eheader.html</a></p></li>
<li><p><a class="reference external" href="https://www.sco.com/developers/gabi/latest/ch5.pheader.html#segment_contents">https://www.sco.com/developers/gabi/latest/ch5.pheader.html#segment_contents</a></p></li>
</ul>
</div>
</div>
<div class="section" id="elf-mapping">
<h4>ELF mapping<a class="headerlink" href="#elf-mapping" title="本標題的永久連結">¶</a></h4>
<p>You can use <code class="docutils literal notranslate"><span class="pre">mmap</span></code> to create regions for the ELF file according to the LOAD segments in program headers.</p>
<p>Normally, you can use
<code class="code docutils literal notranslate"><span class="pre">mmap(p_vaddr,</span> <span class="pre">p_filesz,</span> <span class="pre">p_flags,</span> <span class="pre">MAP_FIXED</span> <span class="pre">|</span> <span class="pre">MAP_POPULATE,</span> <span class="pre">bin_start,</span> <span class="pre">p_offset);</span> <span class="pre">//</span> <span class="pre">MAP_POPULATE</span> <span class="pre">can</span> <span class="pre">be</span> <span class="pre">removed</span> <span class="pre">if</span> <span class="pre">demand</span> <span class="pre">paging</span> <span class="pre">implemented</span></code>
to create a memory region, and <a class="reference internal" href="#region-map"><span class="std std-ref">Region page mapping</span></a> can do the mapping and copying jobs for you.</p>
<p>However, there are some cases you need to care about:</p>
<div class="section" id="p-memsz-p-filesz">
<h5>p_memsz &gt; p_filesz<a class="headerlink" href="#p-memsz-p-filesz" title="本標題的永久連結">¶</a></h5>
<p>It usually happens in .bss and .data are in one LOAD segment, or .bss has its own LOAD segment.
In this case, <strong>.data</strong> should still <strong>map to the ELF file</strong> but <strong>.bss</strong> should <strong>map to anonymous page frames</strong> by seting MAP_ANONYMOUS because it’s not backed by the ELF file.</p>
<p>If unfortunately, <strong>.bss and .data are in the same segment</strong> and their <strong>boundary is at the middle of a page frame</strong>.
You should</p>
<ol class="arabic simple">
<li><p>Do the same thing as normal file mapping region as in <a class="reference internal" href="#region-map"><span class="std std-ref">Region page mapping</span></a></p></li>
<li><p>Set the region’s belong to .bss in the page frame to be 0 because .bss should be 0 initialized.</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>If you implement demand paging, you should pre-fault on the .data and .bss boundary and make .bss’s head 0 initialized.</p>
</div>
</div>
<div class="section" id="p-vaddr-and-p-offset-are-not-page-aligned">
<h5>p_vaddr and p_offset are not page aligned<a class="headerlink" href="#p-vaddr-and-p-offset-are-not-page-aligned" title="本標題的永久連結">¶</a></h5>
<p>The region created by <code class="docutils literal notranslate"><span class="pre">mmap</span></code> should be page aligned.
With the MAP_FIXED flag, some parameters need to be modified</p>
<ul class="simple">
<li><p><strong>addr</strong> should be set to <strong>p_vaddr</strong> - (<strong>p_vaddr</strong> MOD <strong>page_size</strong>)</p></li>
<li><p><strong>file_offset</strong> should be set to <strong>p_offset</strong> - (<strong>p_offset</strong> MOD <strong>page_size</strong>)</p></li>
<li><p><strong>len</strong> should be set to <strong>p_filesz</strong> + (<strong>p_offset</strong> MOD <strong>page_size</strong>)</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">elective</span> <span class="pre">2-2</span></code> Implement ELF mapping.</p>
</div>
</div>
</div>
<div class="section" id="page-fault-handler-demand-paging">
<h3>Page fault handler &amp; demand paging<a class="headerlink" href="#page-fault-handler-demand-paging" title="本標題的永久連結">¶</a></h3>
<p>The page frames are pre-allocated in previous exercise.
However, user program might allocate a huge space on heap or memory mapped files.
Kerenl waste time and memory on this things.</p>
<p>In this exercise, you need to allocate page frames for stack on demand.
You only allocate PGD in the beggining, the others are delayed.</p>
<p>When a page fault is generated,</p>
<ul>
<li><p>If the fault address is not part of any region in the address space,</p>
<ul class="simple">
<li><p>a segmentation fault is generated and the task should be killed.</p></li>
</ul>
</li>
<li><p>If it’s part of one region,</p>
<p>Follow <a class="reference internal" href="#region-map"><span class="std std-ref">Region page mapping</span></a> but only map <strong>one page frame</strong>. for the fault address.</p>
</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">elective</span> <span class="pre">3</span></code> Implement demand paging.</p>
</div>
<div class="section" id="copy-on-write">
<h3>Copy on write<a class="headerlink" href="#copy-on-write" title="本標題的永久連結">¶</a></h3>
<p>When a task call fork to create a child task, you need to copy all the page frames owned by the parent task in the previous implementation.
Otherwise, a write by either child or parent might not be awared by the other one and induce error.</p>
<p>However, an exec followed by fork is quite common in UNIX programming.
The original mapping of child task would be destoryed and you waste a lot of time on copying never used page frames.
Hence, a copy-on-write mechanism comes to help these odds.</p>
<p>The following statements are how you can implement copy-on-write.</p>
<div class="section" id="on-fork-a-new-task">
<h4>On fork a new task<a class="headerlink" href="#on-fork-a-new-task" title="本標題的永久連結">¶</a></h4>
<ol class="arabic simple">
<li><p>Copy the page frames of page tables.</p></li>
<li><p>Then mark PTE entries of <strong>both child and parent</strong> to be <strong>read-only</strong> even for a original read-write page.</p></li>
</ol>
</div>
<div class="section" id="when-either-childs-or-parent-write-to-that-page">
<h4>When either childs or parent write to that page<a class="headerlink" href="#when-either-childs-or-parent-write-to-that-page" title="本標題的永久連結">¶</a></h4>
<p>A permission fault is generated because the PTE entry marks as read-only, then you should</p>
<p>Check the region’s permission in the address space.</p>
<ul class="simple">
<li><p>If the corresponding region is <strong>read-only</strong>, then the <strong>segmentation fault</strong> is generated because user trying to write a read-only region.</p></li>
<li><p>If the corresponding region is <strong>read-wrtie</strong>, then it’s a <strong>copy-on-write fault</strong>.</p>
<ul>
<li><p>Kernel should allocate one page frame, copy the data, and modify the table’s entry to be correct permission.</p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>Because fork may be executed many times, page frames are shared by many childs and one parent, so you need reference count for a page frame.
And you should not reclaim the page frame if still someone refer to it.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">elective</span> <span class="pre">4</span></code> Implement copy-on-write.</p>
</div>
</div>
<div class="section" id="id1">
<h3>Test commands<a class="headerlink" href="#id1" title="本標題的永久連結">¶</a></h3>
<p>The following test commands are recommended to be added to your user shell to test the requirements.
If you don’t follow it, you need to guarantee that your testing code meet our requirements.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">read_beyond_boundary</span><span class="p">(){</span>
  <span class="k">if</span><span class="p">(</span><span class="n">fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="p">,</span> <span class="n">MAP_ANONYMOUS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;addr: %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">1000</span><span class="p">]);</span> <span class="c1">// should be 0</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">4097</span><span class="p">]);</span> <span class="c1">// should be seg fault</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">write_beyond_boundary</span><span class="p">(){</span>
  <span class="k">if</span><span class="p">(</span><span class="n">fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_ANONYMOUS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;addr: %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
    <span class="n">ptr</span><span class="p">[</span><span class="mi">1000</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">1000</span><span class="p">]);</span> <span class="c1">// should be 100</span>
    <span class="n">ptr</span><span class="p">[</span><span class="mi">4097</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span><span class="c1">// should be seg fault</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">4097</span><span class="p">]);</span> <span class="c1">// not reached</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">wrong_permission</span><span class="p">(){</span>
  <span class="k">if</span><span class="p">(</span><span class="n">fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="p">,</span> <span class="n">MAP_ANONYMOUS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;addr: %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">1000</span><span class="p">]);</span> <span class="c1">// should be 0</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4096</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// should be seg fault</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4096</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// not reached</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#pragma GCC optimize(&quot;O0&quot;)</span>
<span class="kt">int</span> <span class="nf">stack_overflow</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">1024</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Recursive %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
  <span class="n">stack_overflow</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">1023</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">test_stack_overflow</span><span class="p">(){</span>
  <span class="k">if</span><span class="p">(</span><span class="n">fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">stack_overflow</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">mmaps</span><span class="p">(){</span> <span class="c1">// test multiple mmaps</span>
  <span class="k">if</span><span class="p">(</span><span class="n">fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">40</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="n">PROT_WRITE</span><span class="o">|</span><span class="n">PROT_READ</span><span class="p">,</span> <span class="n">MAP_ANONYMOUS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">){</span>
        <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_ANONYMOUS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="n">PROT_WRITE</span><span class="o">|</span><span class="n">PROT_READ</span><span class="p">,</span> <span class="n">MAP_ANONYMOUS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// hang to let shell see the mapped regions</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">mmap_unalign</span><span class="p">(){</span>
  <span class="k">if</span><span class="p">(</span><span class="n">fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;0x%llx&quot;</span><span class="p">,</span> <span class="n">mmap</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mh">0x12345678</span><span class="p">,</span> <span class="mh">0x1fff</span><span class="p">,</span> <span class="n">PROT_WRITE</span><span class="o">|</span><span class="n">PROT_READ</span><span class="p">,</span> <span class="n">MAP_ANONYMOUS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span> <span class="c1">// should be a page aligned address A and region should be A - A +0x2000</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// hang to let shell see the mapped regions</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">write_text</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">pc</span><span class="p">;</span>
    <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span>
      <span class="s">&quot;adr %0, .&quot;</span>
      <span class="o">:</span><span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">pc</span><span class="p">)</span>
    <span class="p">);</span>
    <span class="o">*</span><span class="n">pc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// seg fault</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../hardware/asm.html" class="btn btn-neutral float-right" title="The Assembly You Need" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="lab4.html" class="btn btn-neutral float-left" title="Lab 4 : Multitasking" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Jim

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>